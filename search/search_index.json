{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Algo.Py Documentation","text":"<p>Welcome to the documentation for Algo.Py, a comprehensive quantitative trading framework. This documentation covers installation, quickstart guides, core features (backtesting, deployment, FinStore, strategy development), configuration, and API reference.</p>"},{"location":"#navigation","title":"Navigation","text":""},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Installation</li> <li>Quickstart Guide</li> </ul>"},{"location":"#core-features","title":"Core Features","text":"<ul> <li>FinStore</li> <li>Strategy Development</li> <li>Deployment</li> <li>Features Overview</li> </ul>"},{"location":"#configuration","title":"Configuration","text":"<ul> <li>Basic Configuration</li> <li>Advanced Topics</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":""},{"location":"advanced_topics/","title":"Advanced Topics","text":""},{"location":"advanced_topics/#advanced-topics","title":"Advanced Topics","text":"<p>This section explores advanced configuration and customization options for Algo.Py.</p>"},{"location":"advanced_topics/#customizing-the-data-layer","title":"Customizing the Data Layer","text":"<ul> <li>Extend FinStore to support additional data sources or file formats.</li> <li>Fine-tune caching strategies to maximize performance.</li> </ul>"},{"location":"advanced_topics/#extending-oms-and-rms","title":"Extending OMS and RMS","text":"<ul> <li>Integrate with additional brokers or create custom order management modules.</li> <li>Adjust risk management settings to suit complex trading strategies.</li> </ul>"},{"location":"advanced_topics/#performance-optimization","title":"Performance Optimization","text":"<ul> <li>Use libraries such as NumPy and Numba to optimize numerical computations.</li> <li>Profile your code to identify and resolve performance bottlenecks.</li> </ul>"},{"location":"advanced_topics/#debugging-and-logging","title":"Debugging and Logging","text":"<ul> <li>Set up advanced logging configurations for detailed troubleshooting.</li> <li>Monitor live deployments with enhanced logging and alerting tools.</li> </ul>"},{"location":"configuration/","title":"Basic Configuration","text":""},{"location":"configuration/#basic-configuration","title":"Basic Configuration","text":"<p>This section covers the basic configuration steps for Algo.Py.</p>"},{"location":"configuration/#environment-setup","title":"Environment Setup","text":"<ul> <li>Ensure you have a suitable Python environment.</li> <li>Clone the repository and install all required dependencies.</li> <li>Set environment variables in the <code>config/.env</code> file. For example:</li> </ul> <pre><code># Example configuration settings\nAPI_KEY=your_api_key\nAPI_SECRET=your_api_secret\nOMS_TYPE=binance  # Options: telegram, zerodha, binance\n</code></pre>"},{"location":"configuration/#dashboard-and-oms-settings","title":"Dashboard and OMS Settings","text":"<ul> <li>The dashboard configuration is managed in the Streamlit application (<code>Dashboard/main_dash.py</code>).</li> <li>OMS credentials and settings are provided via configuration files.</li> <li>Additional options are detailed in the Advanced Topics section.</li> </ul>"},{"location":"deployment/","title":"Deployment","text":""},{"location":"deployment/#deployment","title":"Deployment","text":"<p>Algo.Py offers an intuitive one\u2011click deployment system for live trading.</p>"},{"location":"deployment/#oneclick-deployment-workflow","title":"One\u2011Click Deployment Workflow","text":"<ol> <li> <p>Backtest and Save:    Run and save your backtest to capture the strategy\u2019s configuration and performance metrics.</p> </li> <li> <p>Navigate to the Deployment Dashboard:    Open the Strategy Deployment page in the Streamlit dashboard.</p> </li> <li> <p>Load a Backtest (Optional):    Use the Load Backtest button to auto\u2011populate deployment settings from a saved backtest.</p> </li> <li> <p>Configure Deployment Settings:</p> </li> <li> <p>Scheduler: </p> <ul> <li>Fixed Interval: Set the run interval (in minutes).  </li> <li>Specific Time: Choose an execution time (with timezone).</li> </ul> </li> <li> <p>OMS (Order Management System):      Select your OMS (e.g., Telegram, Zerodha, or Binance) and provide the required credentials.</p> </li> <li> <p>Additional Settings:      Set initial cash, start date, trade size, cash sharing, and partial order options.</p> </li> <li> <p>Deploy:    Click the Deploy Strategy button. A new process is spawned to handle live execution, and you can monitor its status, logs, and performance via the dashboard.</p> </li> </ol>"},{"location":"deployment/#behind-the-scenes","title":"Behind the Scenes","text":"<ul> <li>A dedicated process is launched for deployment.</li> <li>The saved configuration is loaded and the OMS is initialized.</li> <li>A scheduler triggers data fetching, signal generation, and order execution.</li> <li>Deployment status and logs are continuously updated.</li> </ul>"},{"location":"features/","title":"Features Overview","text":""},{"location":"features/#features-overview","title":"Features Overview","text":"<p>Algo.Py is a comprehensive algorithmic trading platform that covers every stage from strategy development and backtesting to live deployment.</p>"},{"location":"features/#key-features","title":"Key Features","text":""},{"location":"features/#backtesting-deployment","title":"Backtesting &amp; Deployment","text":"<ul> <li>Vectorized Backtesting: Uses the <code>vectorbtpro</code> library for fast historical testing.</li> <li>Detailed Metrics: Computes total return, Sharpe ratio, Sortino ratio, maximum drawdown, win rate, profit factor, and more.</li> <li>Interactive Charts: Displays interactive Plotly charts including equity curves and cumulative returns.</li> <li>One\u2011Click Deployment: Seamlessly transition from backtesting to live trading.</li> </ul>"},{"location":"features/#strategy-development","title":"Strategy Development","text":"<ul> <li>Modular Design: Build strategies on a consistent structure.</li> <li>Automatic Registration: Strategies in the <code>strategy/public</code> directory are auto\u2011registered.</li> <li>Parameter Exposure: Strategy parameters are automatically made configurable in dashboards.</li> <li>Built\u2011in Indicators: Pre\u2011built indicators (EMA, Supertrend, RSI, etc.) plus support for custom indicators.</li> <li>Multi\u2011Asset Support: Run strategies on multiple assets simultaneously.</li> </ul>"},{"location":"features/#custom-data-layer-finstore","title":"Custom Data Layer (FinStore)","text":"<ul> <li>Organized Storage: Data is categorized by market and timeframe.</li> <li>Efficient Format: Leverages Parquet for compact, fast data storage.</li> <li>Incremental Updates: Easily add new data without overwriting previous files.</li> <li>Caching: Uses integrated caching to boost performance.</li> </ul>"},{"location":"features/#multibroker-market-support","title":"Multi\u2011Broker &amp; Market Support","text":"<ul> <li>Market Versatility: Supports both cryptocurrency (Binance) and Indian equities.</li> <li>Extensible Architecture: Easily integrate additional markets and data sources.</li> <li>Timeframe Flexibility: Operates across various timeframes (1m, 5m, 15m, 1h, 4h, 1d).</li> </ul>"},{"location":"features/#order-and-risk-management","title":"Order and Risk Management","text":"<ul> <li>OMS Integration: Connects with multiple order management systems (Telegram, Zerodha, Binance).</li> <li>Automated Order Execution: Executes trades automatically based on strategy signals.</li> <li>Risk Tools: Provides basic risk management features such as position sizing and cash sharing.</li> </ul>"},{"location":"features/#live-trading-dashboards","title":"Live Trading Dashboards","text":"<ul> <li>Streamlit Based: User-friendly, real-time dashboards.</li> <li>Visual Tools: Features live DOM charts, footprint charts, and more.</li> <li>AI Enhancements: Upcoming features include an AI Trading Journal and AI backtesting agent.</li> </ul>"},{"location":"finstore/","title":"FinStore","text":""},{"location":"finstore/#finstore","title":"FinStore","text":"<p>FinStore is the custom data layer for Algo.Py\u2014optimized for fast data storage, retrieval, and incremental updates using DuckDB and Parquet.</p>"},{"location":"finstore/#key-features","title":"Key Features","text":"<ul> <li>Organized Data Storage: Data is structured by market (e.g., <code>crypto_binance</code>, <code>indian_equity</code>) and timeframe (e.g., 1d, 4h). Files are stored in the <code>database/finstore</code> directory.</li> <li>Efficient Storage: Uses Parquet for compressed, columnar storage.</li> <li>Simplified API: A straightforward API (<code>Finstore</code>) for reading/writing OHLCV data and technical indicators.</li> <li>Incremental Updates: Add new data without overwriting existing files.</li> <li>Caching: Integrated caching (using <code>diskcache</code>) improves performance.</li> </ul>"},{"location":"finstore/#exploring-finstore","title":"Exploring FinStore","text":"<p>Browse the <code>database/finstore</code> directory to see data organized by market and timeframe. Each symbol\u2019s folder contains files like <code>ohlcv_data.parquet</code> and <code>technical_indicators.parquet</code>.</p>"},{"location":"finstore/#using-finstore-programmatically","title":"Using FinStore Programmatically","text":"<pre><code>from finstore.finstore import Finstore\n\n# Initialize FinStore\nfinstore = Finstore(market_name='crypto_binance', timeframe='4h', pair='BTC')\n\n# Get available symbols\nsymbol_list = finstore.read.get_symbol_list()\nprint(symbol_list)\n\n# Fetch data for one symbol\nsymbol, ohlcv_data = finstore.read.symbol(symbol_list[0])\nprint(symbol)\nprint(ohlcv_data.head())\n\n# Get merged dataframe (OHLCV + indicators)\nsymbol, merged_df = finstore.read.merged_df(symbol_list[0])\nprint(symbol)\nprint(merged_df.head())\n\n# Calculate and write a technical indicator (e.g., EMA)\nfrom utils.calculation.indicators import calculate_ema\nohlcv_data_dict = finstore.read.symbol_list(symbol_list=symbol_list)\nfinstore.write.indicator(ohlcv_data=ohlcv_data_dict, calculation_func=calculate_ema, length=20)\n</code></pre>"},{"location":"finstore/#extending-finstore","title":"Extending FinStore","text":"<p>Feel free to extend FinStore\u2019s functionality to support additional data sources or technical indicators.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":"<p>Follow these steps to set up Algo.Py:</p> <p>Clone the Repository:</p> <pre><code>git clone https://github.com/himanshu2406/Algo.Py.git\ncd Algo.Py\n</code></pre> <p>Select your Backtesting Backend:</p> <p>Change your backtest backend to be installed in the <code>docker-compose.yml</code> file</p> <p>The default is set to <code>vectorbt</code> [Options : <code>vectorbt</code> , <code>vectorbtpro</code>, <code>nautilus</code> (coming soon)]</p> <pre><code>args:\n   - BACKTEST_BACKEND=vectorbt\n</code></pre> <p>Note : In case <code>vectorbtpro</code> is chosen , change your .env appropriately : </p> <pre><code>BACKTEST_BACKEND=vectorbtpro\n</code></pre> <p>Start the Docker Container:</p> <pre><code>docker compose up -d\n</code></pre> <p>More information on Backtest Backends</p> <p>You have the following options for backtesting:    - vectorbt    - vectorbtpro    - nautilus trader (WIP)</p> <p>To enable backtesting, you must install one of these libraries first.    This is done during the docker build process by selecting the appropriate option from available Backtest Backends.</p> <p>However , if you've installed <code>vectorbt</code> and want to migrate to <code>vectorbtpro</code> instead , you can do this easily - </p> <p>Steps to Re-Install:</p> <ol> <li> <p>Enter the Docker Container:</p> <pre><code>docker exec -it algopy_app bash\n</code></pre> </li> <li> <p>Uninstall <code>vectorbt</code> (Free Version):</p> <pre><code>pip uninstall vectorbt\n</code></pre> </li> <li> <p>Install <code>vectorbtpro</code>:</p> <ul> <li>Clone your copy of <code>vectorbtpro</code> and install it: <pre><code>cd vectorbt.pro-main\npip install -e .\n</code></pre></li> </ul> </li> <li> <p>Change your .env</p> <pre><code>BACKTEST_BACKEND=vectorbtpro\n</code></pre> </li> </ol> <p>Nautilus Trader (WIP):       Nautilus Trader integration is currently a work in progress and has not yet been integrated with Algo.Py. Stay tuned for future updates!</p>"},{"location":"quickstart/","title":"Quickstart Guide","text":""},{"location":"quickstart/#quickstart-guide","title":"Quickstart Guide","text":"<p>This guide provides step-by-step instructions for performing a backtest, deploying a strategy, and using the different trading dashboards.</p>"},{"location":"quickstart/#running-a-backtest","title":"Running a Backtest","text":"<ol> <li> <p>Start the Dashboard:</p> </li> <li> <p>After installation, streamlit dashboard and jupyter notebook are both automatically spun up, you can access these using : </p> </li> </ol> <p>Streamlit <pre><code>localhost:8501\n</code></pre></p> <p>Jupyter <pre><code>localhost:8888\n</code></pre></p> <p>Access environment inside container     open a terminal and run:</p> <pre><code>docker exec -it algopy_app bash\n</code></pre> <ul> <li> <p>[Recommended] Alternatively, if you use VS Code, install the Docker extension, navigate to Containers, right-click on <code>algopy_app</code>, and select Attach Visual Studio Code. This opens a new window attached to the container, eliminating the need to manually export ports and providing a perfect environment (including running Jupyter notebooks seamlessly).</p> </li> <li> <p>Once inside the container (starting from the <code>/app</code> directory), launch the Streamlit application:</p> <pre><code>streamlit run Dashboard/main_dash.py\n</code></pre> </li> </ul> <p>Open your browser (typically at http://localhost:8501) and click on the Strategy Backtest link in the navigation.</p> <ol> <li> <p>Configure the Backtest:</p> </li> <li> <p>Timeframe: Choose the timeframe (e.g., 1D, 4H, 1H).</p> </li> <li>Strategy Module: Select a module (e.g., \"EMA Crossover Strategy\").</li> <li>Asset Universe: Search for and select assets (Crypto, Equities, etc.).</li> <li>Strategy Parameters: Adjust settings specific to the chosen strategy.</li> <li> <p>Backtest Settings: Set start/end dates, initial capital, fees, and slippage.</p> </li> <li> <p>Run the Backtest:</p> </li> </ol> <p>Click the \ud83d\ude80 Run Backtest button. A progress bar will indicate the process. Upon completion, you will see detailed performance statistics, interactive charts (including equity curve, cumulative returns, and trade history), and generated signals.</p> <ol> <li>Save the Backtest:</li> </ol> <p>Enter a filename and click the \ud83d\udcbe Save Portfolio button. The configuration and results will be saved for later deployment.</p>"},{"location":"quickstart/#deploying-a-strategy-beta","title":"Deploying a Strategy [Beta]","text":"<p>Warning: This is an early-stage deployment feature. It is not recommended to use with real money. Instead, use it in a sandbox or low-capital environment to validate your strategy. Algo.Py is not responsible for any financial losses incurred.</p> <ol> <li>Navigate to the Deployment Dashboard:</li> </ol> <p>From the Dashboard sidebar, go to the Strategy Deployment section.</p> <ol> <li>Load a Backtest (Optional):</li> </ol> <p>On the Strategy Backtest page, use the Load Previous Backtest section to select a saved backtest. Most deployment settings will auto-populate, though you will still need to select an OMS type and configure its settings.</p> <ol> <li> <p>Configure Deployment Parameters:</p> </li> <li> <p>Strategy: Select your strategy.</p> </li> <li>Strategy Parameters: Adjust as needed.</li> <li>Market Configuration: Choose the market (e.g., <code>crypto_binance</code>, <code>indian_equity</code>) and the timeframe.</li> <li>Asset Universe: Select the assets you wish to trade.</li> <li>Order Management (OMS): Choose between Telegram, Zerodha, or Binance:<ul> <li>Telegram: Provide your bot token and chat ID.</li> <li>Zerodha: Provide your User ID, Password, and TOTP secret.</li> <li>Binance: Provide your API key and secret.</li> </ul> </li> <li>Scheduler Configuration: Choose one:<ul> <li>Fixed Interval: Define the interval (in minutes).</li> <li>Specific Time: Set a daily execution time (with timezone).</li> </ul> </li> <li> <p>Additional Settings: Configure initial cash, start date, trade size, cash sharing, and partial order settings.</p> </li> <li> <p>Deploy:</p> </li> </ol> <p>Click the Deploy Strategy button. The deployment process will start, and you can monitor its status in the Active Deployments section.</p>"},{"location":"quickstart/#order-management-system","title":"Order Management System","text":"<p>Manage your positions in an advanced manner using the Order Management System (OMS). You can choose between Limit Orders and Market Orders.</p>"},{"location":"quickstart/#limit-orders","title":"Limit Orders","text":"<ul> <li>Parameters:</li> <li>Price: Specify the order price.</li> <li>Quantity: Define the amount.</li> <li>Quantity Type: Choose between contracts (e.g., 0.001 BTC to represent 0.001 BTC) or USD (e.g., 100 USD worth of BTC).</li> <li>Order Side: Select Buy or Sell.</li> <li>Leverage: Set your desired leverage.</li> <li>Click Place Order to execute.</li> </ul>"},{"location":"quickstart/#market-orders","title":"Market Orders","text":"<ul> <li>Parameters: Similar to Limit Orders, but without the price field.</li> <li>Limit Order Chaser: An additional feature that:</li> <li>Places limit orders at the closest available price in the order book.</li> <li>Continuously adjusts (\u201cchases\u201d) the market price until the order is filled.</li> </ul> <p>This is beneficial because platforms like Binance and Bybit often charge higher fees for market orders compared to limit orders. The Limit Order Chaser helps reduce fees by ensuring orders fill as limit orders.</p>"},{"location":"quickstart/#orderbook-heatmap","title":"Orderbook Heatmap","text":"<p>This tool visualizes resting orders in the order book as yellow boxes. The darker the yellow, the higher the quantity at that price level. Additionally, executing orders are displayed as bubbles, where a larger bubble indicates a greater order size. Use this tool to identify iceberg orders or bot-driven orders.</p>"},{"location":"quickstart/#footprint-chart","title":"Footprint Chart","text":"<p>The Footprint Chart offers a detailed view of order flow, featuring: - Deltas - Volume point-of-control (POC) - Volume bars for each candle - Rate of Change (ROC)</p> <p>This chart enables enhanced analysis of market order flow for more informed decision-making.</p>"},{"location":"strategy_development/","title":"Strategy Development","text":""},{"location":"strategy_development/#strategy-development","title":"Strategy Development","text":"<p>Developing custom trading strategies is central to Algo.Py. This section explains how to create, test, and contribute your strategies.</p>"},{"location":"strategy_development/#contributing-strategies","title":"Contributing Strategies","text":"<ol> <li> <p>Create a New Python File:    Place your new strategy (e.g., <code>my_new_strategy.py</code>) in the <code>strategy/public</code> directory.</p> </li> <li> <p>Implement the Strategy Class:    Inherit from <code>StrategyBaseClass</code> (in <code>strategy/strategy_builder.py</code>) and implement the <code>run</code> method.</p> </li> <li> <p>Automatic Registration:    Strategies in the <code>strategy/public</code> directory that inherit from <code>StrategyBaseClass</code> are automatically discovered and registered.</p> </li> <li> <p>Test Your Strategy:    Use the backtesting functionality to validate performance.</p> </li> </ol>"},{"location":"strategy_development/#creating-a-custom-strategy","title":"Creating a Custom Strategy","text":"<p>Below is an example implementation:</p> <pre><code>from strategy.strategy_builder import StrategyBaseClass\nimport pandas as pd\nfrom typing import Tuple, Dict\n\nclass MyCustomStrategy(StrategyBaseClass):\n    def __init__(self, param1: int = 10, param2: float = 0.5):\n        super().__init__(name=\"My Custom Strategy\")\n        self.param1 = param1\n        self.param2 = param2\n\n    def run(self, ohlcv_data: Dict[str, pd.DataFrame]) -&gt; Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame, pd.DataFrame]:\n        entries = {}\n        exits = {}\n        close_prices = {}\n        open_prices = {}\n\n        for symbol, df in ohlcv_data.items():\n            # Replace with your custom logic\n            entries[symbol] = pd.Series(False, index=df.index)\n            exits[symbol] = pd.Series(False, index=df.index)\n            close_prices[symbol] = df['close']\n            open_prices[symbol] = df['open']\n\n        return (\n            pd.DataFrame(entries),\n            pd.DataFrame(exits),\n            pd.DataFrame(close_prices),\n            pd.DataFrame(open_prices),\n        )\n</code></pre>"},{"location":"strategy_development/#testing-strategies","title":"Testing Strategies","text":"<ul> <li>Backtesting: Run your strategy against historical data.</li> <li>Live Monitoring: Check real-time performance via the Strategy Monitor dashboard.</li> </ul>"},{"location":"strategy_development/#considerations","title":"Considerations","text":"<ul> <li>Data Integrity: Ensure proper handling of missing values and duplicate timestamps.</li> <li>Performance: Optimize computations, especially for high-frequency data.</li> <li>Avoid Overfitting: Validate your strategy using separate hold-out data.</li> <li>Costs &amp; Slippage: Simulate transaction fees and slippage.</li> <li>Error Handling: Implement robust error handling to avoid crashes.</li> </ul>"}]}